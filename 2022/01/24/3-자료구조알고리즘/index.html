<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>3. 자료구조알고리즘 | Seb&#39;s LegalTech Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="자료구조(Data Structure)는 데이터와 구체화된 관련 연산으로 이루어져 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조를 의미하며 알고리즘(Algorithm)은 문제를 풀기 위한 단계적인 절차를 의미 합니다. 컴퓨터 알고리즘의 조건은 다음과 같습니다.  0개 이상의 입력이 존재할 것 (입력) 1개 이상의 출력이 존재할 것 (출력) 각 명령">
<meta property="og:type" content="article">
<meta property="og:title" content="3. 자료구조알고리즘">
<meta property="og:url" content="http://example.com/2022/01/24/3-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/index.html">
<meta property="og:site_name" content="Seb&#39;s LegalTech Blog">
<meta property="og:description" content="자료구조(Data Structure)는 데이터와 구체화된 관련 연산으로 이루어져 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조를 의미하며 알고리즘(Algorithm)은 문제를 풀기 위한 단계적인 절차를 의미 합니다. 컴퓨터 알고리즘의 조건은 다음과 같습니다.  0개 이상의 입력이 존재할 것 (입력) 1개 이상의 출력이 존재할 것 (출력) 각 명령">
<meta property="og:locale">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151522275-d7fda4dc-58d1-4a00-a8cb-f48b9714692a.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151522324-2bb93c1a-9182-40d6-8fe5-1339c4c87222.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151522359-ef5ad907-22f6-4a73-a4ba-340838762c40.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151522413-fcdecce2-fb8e-47bc-a010-a370d02c438b.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151522423-278e4522-1f61-4dcf-a8f5-da71399393b2.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151475486-19b887a2-12f1-43b1-8a1b-832c32794e9d.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151475966-25c9ff18-5f40-413c-b174-0db2e3113c8a.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151476089-17395489-5ec1-4bd0-85b7-1fc5a4cc67ca.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151477849-47262e97-9455-4b4a-a1b1-92ddfe193736.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151489576-75b88e35-749a-47a8-8562-76ece8f72ab2.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151490808-0fde973e-713d-4dfa-8a86-c4b6f7239c13.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151495585-c76367ba-074b-4faf-8f5f-db4376516089.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151495497-8f55d8ee-1cf9-435b-a51c-e730ee904228.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151495775-bd1f5792-c3b9-4247-a3f2-7b0d27a55830.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151498452-41756d39-560f-4c9f-b0f7-8e31013a726c.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151498391-ddc6fdcf-7768-47b1-b1b4-e35e4bd92917.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151498656-5ada37b5-fa27-4244-8fd8-90b6c1102a56.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151505225-5143e227-fc09-4a15-b15a-25462e05e092.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151506139-2e84c84c-1fb7-43f9-af3d-0781b078f11e.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/84167756/151506174-ce6b4101-b8f1-4247-8f57-3eba03bcb428.png">
<meta property="article:published_time" content="2022-01-24T01:46:05.000Z">
<meta property="article:modified_time" content="2022-02-14T06:39:43.403Z">
<meta property="article:author" content="Sebastian (Il-Hyun) Noh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/84167756/151522275-d7fda4dc-58d1-4a00-a8cb-f48b9714692a.png">
  
    <link rel="alternate" href="/atom.xml" title="Seb's LegalTech Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Seb&#39;s LegalTech Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-3-자료구조알고리즘" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/01/24/3-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" class="article-date">
  <time class="dt-published" datetime="2022-01-24T01:46:05.000Z" itemprop="datePublished">2022-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      3. 자료구조알고리즘
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>자료구조(Data Structure)는 데이터와 구체화된 관련 연산으로 이루어져 컴퓨터에서 자료를 정리하고 조직화하는 다양한 구조를 의미하며 알고리즘(Algorithm)은 문제를 풀기 위한 단계적인 절차를 의미 합니다. 컴퓨터 알고리즘의 조건은 다음과 같습니다.</p>
<ul>
<li>0개 이상의 입력이 존재할 것 (입력)</li>
<li>1개 이상의 출력이 존재할 것 (출력)</li>
<li>각 명령어의 의미가 명확할 것 (명백성)</li>
<li>한정된 수의 단계 후에는 반드시 종료될 것 (유한성)</li>
<li>각 명령어들은 실행 가능한 연산일 것 (유효성)</li>
</ul>
<p>알고리즘의 성능 분석 방법은 다음과 같습니다.</p>
<ul>
<li>실행 시간을 측정하는 방법</li>
<li>알고리즘의 복잡도를 분석하는 방법 (시간 복잡도, 공간복잡도)</li>
</ul>
<p>이제 대표적인 자료구조 형태와 알고리즘을 살펴보겠습니다.</p>
<h2 id="배열-기본-skill-set-이를-가지고-다양한-자료구조-생성-가능">배열 &lt;기본 skill set, 이를 가지고 다양한 자료구조 생성 가능&gt;</h2>
<ul>
<li>같은 자료형을 같는 여러 원소(데이터)를 하나의 변수이름으로 모아 놓은 데이터의 집합입니다.</li>
<li>배열은 구현이 간단하고 각 항목의 위치로 바로 접근이 가능하나 삽입, 삭제시 오버헤드 발생(특정한 목표를 달성하기 위해 간접적 혹은 추가적으로 요구되는 시간) 문제와 항목의 개수가 제한(배열의 크기가 정적으로 결정됨)된다는 문제가 있습니다.</li>
<li>리스트는 순서를 가진 항목들의 모임으로 항목간의 순서의 개념이 없는 집합과 비교되는데 배열로 구현 가능(뒤에 나오는 연결된 구조로도 구현 가능)합니다. 파이썬 리스트의 경우 자료형이 다른 여러 원소를 하나의 변수이름으로 모아 놓을 수 있습니다.</li>
</ul>
<h2 id="연결리스트-기본-skill-set-이를-가지고-다양한-자료구조-생성-가능">연결리스트 &lt;기본 skill set, 이를 가지고 다양한 자료구조 생성 가능&gt;</h2>
<p>연결리스트는 흩어진 데이터를 링크를 연결해서 관리하는 것으로 용량이 고정되어있지 않으며 중간에 자료를 삽입하거나 삭제하는 것에 용이 합니다.</p>
<h3 id="단순연결리스트singly-linked-list">단순연결리스트(Singly Linked List)</h3>
<p>단순연결리스트는 동적 메모리 할당(컴퓨터 프로그래밍에서 실행 시간 동안 사용할 메모리 공간을 할당하는 것으로 어떤 프로그램이 실행하는 순간 프로그램이 사용할 메모리 크기를 고려하여 메모리의 할당이 이루어지는 정적 메모리 할당과 대조적)을 받아 노드(node)를 저장하고 노드는 레퍼런스를 이용하여 다음 노드를 가리키도록 노드들을 한줄로 연결시키는 가장 간단한 형태의 자료구조 입니다.</p>
<p>연결리스트에서 항목을 탐색하려면 항상 첫 노드부터 원하는 노드를 찾을 때까지 차례로 방문하는 순차탐색(Sequential Search)을 해야 합니다.</p>
<h3 id="이중연결리스트doubly-linked-list">이중연결리스트(Doubly Linked List)</h3>
<p>이중연결리스트는 단순연결리스트와 달리 각 노드가한 개가 아닌 두 개의 레퍼런스를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결리스트로 역방향 노드 탐색이 가능합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dlist</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, elem, prev, <span class="built_in">next</span></span>):</span> <span class="comment">#노드 생성자 항목, 이전 노드 레퍼런스, 다음 노드 레퍼런스</span></span><br><span class="line">            self.elem = elem</span><br><span class="line">            self.prev = prev</span><br><span class="line">            self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment"># 이중연결리스트 생성자 head와 tail, 항목 수로 구성</span></span><br><span class="line">        self.head = self.Node(<span class="literal">None</span>, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        self.tail = self.Node(<span class="literal">None</span>, self.head, <span class="literal">None</span>)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.size == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, r, elem</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == self.head:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"invalid position."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t = r.prev</span><br><span class="line">            n = self.Node(elem, t, r)</span><br><span class="line">            r.prev = n</span><br><span class="line">            t.<span class="built_in">next</span> = n</span><br><span class="line">            self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, r</span>):</span></span><br><span class="line">        <span class="keyword">if</span> r == self.head:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"invalid position."</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a = r.prev</span><br><span class="line">            b = r.<span class="built_in">next</span></span><br><span class="line">            a.<span class="built_in">next</span> = b</span><br><span class="line">            b.prev = a</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_order</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.cursor = self.head</span><br><span class="line">        <span class="keyword">if</span> self.size + <span class="number">1</span> &gt;= n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                self.cursor = self.cursor.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"invalid position."</span>)</span><br><span class="line">        <span class="keyword">return</span> self.cursor            <span class="comment">#### 노드 위치 지정</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprintt</span>(<span class="params">self</span>):</span></span><br><span class="line">        r = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> r != self.tail:</span><br><span class="line">            <span class="built_in">print</span>(r.elem, end=<span class="string">''</span>)</span><br><span class="line">            r = r.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line"></span><br><span class="line">    d_list = Dlist()</span><br><span class="line"></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"연산의 개수:"</span>))</span><br><span class="line">    <span class="keyword">while</span> count &lt;= n:</span><br><span class="line"></span><br><span class="line">        instruction = <span class="built_in">input</span>(<span class="string">""</span>) <span class="comment"># 입력: 연산의 종류, 순위, 원소</span></span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"A"</span>: <span class="comment"># add</span></span><br><span class="line">            a, b, c = instruction.split(<span class="string">" "</span>)</span><br><span class="line">            d_list.add(d_list.get_order(<span class="built_in">int</span>(b)), c)</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span>: <span class="comment"># delete</span></span><br><span class="line">            a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">            d_list.delete(d_list.get_order(<span class="built_in">int</span>(b)))</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"G"</span>: <span class="comment"># get</span></span><br><span class="line">            a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">            <span class="built_in">print</span>(d_list.get_order(<span class="built_in">int</span>(b)).elem)   <span class="comment">### 노드 생성자 항목   노드.elem</span></span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span>: <span class="comment"># print</span></span><br><span class="line">            a = <span class="string">"P"</span></span><br><span class="line">            d_list.pprintt()</span><br><span class="line"></span><br><span class="line">        count = count + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="원형연결리스트circular-linked-list">원형연결리스트(Circular Linked List)</h3>
<p>원형연결리스트는 마지막 노드가 첫 노드와 연결된 단순연결리스트입니다.</p>
<h2 id="스택stack">2. 스택(Stack)</h2>
<p>스택(Stack)은 후입 선출(Last-In First-Out, LIFO)원칙 하에 한 쪽 끝에서만 item을 삭제하거나 새로운 item을 저장하는 자료구조입니다.</p>
<p>스택은 괄호검사(각각의 괄호들의 짝이 맞는지 검사), 괄호 없이 중위표기법 수식을 표현할 수 있는 후위 표기식 계산(<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="25.143ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 11113.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mo" transform="translate(1722.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(2111.4,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(2833.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3833.9,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(4333.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(5000.7,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g><g data-mml-node="mn" transform="translate(6278.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(6778.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(7223.1,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g><g data-mml-node="mo" transform="translate(7723.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(8167.8,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g><g data-mml-node="mo" transform="translate(8667.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(9112.4,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mo" transform="translate(9890.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(10335.1,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g></g></g></svg></mjx-container></span>) 및 함수/메소드 호출 및 재귀호출 구현 등에 활용됩니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.top) == <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.top)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span> self.top = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span> <span class="comment"># 스택에 데이터 추가</span></span><br><span class="line">        self.top.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span> <span class="comment"># 스택의 탑(리스트 마지막) 데이터를 반환하고 스택에서 제거, 스택이 비어 있으면 "Stack Empty"를 출력</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.top.pop(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.isEmpty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Stack Empty"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span> <span class="comment"># 스택의 탑(리스트 마지막) 데이터를 화면에 출력, 스택은 변하지 않음</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="built_in">print</span>(self.top[-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">elif</span> self.isEmpty():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Stack Empty"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">duplicate</span>(<span class="params">self</span>):</span> <span class="comment">#스택의 탑(리스트 마지막) 데이터를 pop 해서 두번 push</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            ch=self.top.pop(-<span class="number">1</span>)</span><br><span class="line">            self.top.append(ch)</span><br><span class="line">            self.top.append(ch)</span><br><span class="line">            <span class="keyword">return</span> self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printt</span>(<span class="params">self</span>):</span> <span class="comment">#택의 탑(리스트 마지막)부터 순서대로 출력</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.top[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="built_in">print</span>(i,end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upRotate</span>(<span class="params">self, n</span>):</span> <span class="comment"># 스택 맨 위 n개의 데이터를 하나씩 위쪽으로 회전, 단, n이 데이터의 개수보다 큰 경우에는 아무런 작업 하지 않음</span></span><br><span class="line">        n=<span class="built_in">int</span>(n)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="built_in">len</span>(self.top):</span><br><span class="line">            a=self.top[-<span class="number">1</span>]</span><br><span class="line">            count = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> count&gt;-n:</span><br><span class="line">                self.top[count] = self.top[count-<span class="number">1</span>]</span><br><span class="line">                count= count-<span class="number">1</span></span><br><span class="line">            self.top[-n] = a</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="built_in">len</span>(self.top):</span><br><span class="line">            <span class="keyword">return</span> self.top</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">downRotate</span>(<span class="params">self, n</span>):</span> <span class="comment"># 스택 맨 위 n개의 데이터를 하나씩 아래쪽으로 회전, 단, n이 데이터의 개수보다 큰 경우에는 아무런 작업 하지 않음</span></span><br><span class="line">        n = <span class="built_in">int</span>(n)</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="built_in">len</span>(self.top):</span><br><span class="line">            b=self.top[-n]</span><br><span class="line">            count=-n</span><br><span class="line">            <span class="keyword">while</span> count&lt;-<span class="number">1</span>:</span><br><span class="line">                self.top[count]=self.top[count+<span class="number">1</span>]</span><br><span class="line">                count=count+<span class="number">1</span></span><br><span class="line">            self.top[-<span class="number">1</span>]=b</span><br><span class="line">        <span class="keyword">elif</span> n&gt;<span class="built_in">len</span>(self.top):</span><br><span class="line">            <span class="keyword">return</span> self.top</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    stack=Stack()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류(POP, PUSH, PEEK, DUP, UpR, DownR, PRINT)와 영문자를 입력하세요:"</span>)</span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>]==<span class="string">"U"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>]==<span class="string">"S"</span> <span class="keyword">and</span> instruction[<span class="number">3</span>]==<span class="string">"H"</span>:</span><br><span class="line">            stack.push(instruction[<span class="number">5</span>])</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"O"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>] == <span class="string">"P"</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>]==<span class="string">"E"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>]==<span class="string">"E"</span> <span class="keyword">and</span> instruction[<span class="number">3</span>]==<span class="string">"K"</span>:</span><br><span class="line">            stack.peek()</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"U"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>] == <span class="string">"P"</span>:</span><br><span class="line">            stack.duplicate()</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"U"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"p"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>] == <span class="string">"R"</span>:</span><br><span class="line">            stack.upRotate(instruction[<span class="number">4</span>])</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"o"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>] == <span class="string">"w"</span> <span class="keyword">and</span> instruction[<span class="number">3</span>] == <span class="string">"n"</span> <span class="keyword">and</span> \</span><br><span class="line">                instruction[<span class="number">4</span>] == <span class="string">"R"</span>:</span><br><span class="line">            stack.downRotate(instruction[<span class="number">6</span>])</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"R"</span> <span class="keyword">and</span> instruction[<span class="number">2</span>] == <span class="string">"I"</span> <span class="keyword">and</span> instruction[<span class="number">3</span>] == <span class="string">"N"</span> <span class="keyword">and</span> \</span><br><span class="line">                instruction[<span class="number">4</span>] == <span class="string">"T"</span>:</span><br><span class="line">            stack.printt()</span><br><span class="line">            <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 스택을 활용한 괄호검사</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.top = [] <span class="comment">#스택을 파이썬리스트로 구현</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.top) == <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.top)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span>(<span class="params">self</span>):</span> self.top = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self.top.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.top.pop(-<span class="number">1</span>) <span class="comment"># 스택의 탑(리스트 마지막) 항목을 반환하고 스택에서 제거</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.top[-<span class="number">1</span>] <span class="comment"># 스택의 탑(리스트 마지막) 항목 리턴, 화면에 출력, 스택 값은 변하지 않음</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkBrackets</span>(<span class="params">statement</span>):</span></span><br><span class="line">    stack=Stack()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> statement:</span><br><span class="line">        <span class="keyword">if</span> ch <span class="keyword">in</span> (<span class="string">'{'</span>,<span class="string">'['</span>,<span class="string">'('</span>):</span><br><span class="line">            stack.push(ch)</span><br><span class="line">        <span class="keyword">elif</span> ch <span class="keyword">in</span> (<span class="string">'}'</span>,<span class="string">']'</span>,<span class="string">')'</span>):</span><br><span class="line">            <span class="keyword">if</span> stack.isEmpty():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># False이면 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다는 조건 위반</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> (ch==<span class="string">'}'</span> <span class="keyword">and</span> left !=<span class="string">'{'</span>) <span class="keyword">or</span>\</span><br><span class="line">                   (ch==<span class="string">']'</span> <span class="keyword">and</span> left !=<span class="string">'['</span>) <span class="keyword">or</span>\</span><br><span class="line">                   (ch==<span class="string">')'</span> <span class="keyword">and</span> left !=<span class="string">'('</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span> <span class="comment"># False이면 괄호 사이에는 포함 관계만 존재한다는 조건 위반</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty() <span class="comment"># Flase이면 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다는 조건 위반</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span> :</span><br><span class="line"></span><br><span class="line">sentence=<span class="built_in">str</span>(<span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">"1000개 이하의 문자로 구성된 수식문장을 입력하세요:"</span>)))</span><br><span class="line">a = sentence.count(<span class="string">'{'</span>)</span><br><span class="line">b = sentence.count(<span class="string">'['</span>)</span><br><span class="line">c = sentence.count(<span class="string">'('</span>)</span><br><span class="line">d = sentence.count(<span class="string">'}'</span>)</span><br><span class="line">e = sentence.count(<span class="string">']'</span>)</span><br><span class="line">f = sentence.count(<span class="string">')'</span>)</span><br><span class="line">N = a+b+c+d+e+f</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sentence)&lt;=<span class="number">1000</span>:</span><br><span class="line">    result=checkBrackets(sentence)</span><br><span class="line">    <span class="keyword">if</span> result == <span class="literal">False</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Wrong_%d'</span> %N)</span><br><span class="line">    <span class="keyword">elif</span> result == <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Ok_%d'</span> %N)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"수식문장이 1,000개의 문자를 넘었습니다."</span>)</span><br></pre></td></tr></table></figure>
<h2 id="큐queue">3. 큐(Queue)</h2>
<p>큐(Queue)는 선입선출(First-In First Out: FIFO)의 자료구조로서 삽입은 후단(rear)에서만 해야하고 삭제는 전단(front)에서만 할 수 있습니다. 선형큐보다 원형큐가 훨씬 효육적입니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 원형 큐</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.front=<span class="number">0</span> <span class="comment"># 전단 초기 값은 0</span></span><br><span class="line">        self.rear=<span class="number">0</span> <span class="comment">#  후단 초기 값은 0</span></span><br><span class="line">        self.items=[<span class="number">0</span>]*MAX_QSIZE <span class="comment"># 배열의 초기 값은 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.front == self.rear <span class="comment"># 전단과 후단이 같으면 공백 상태</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFull</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.front == (self.rear+<span class="number">1</span>)%MAX_QSIZE <span class="comment">#전단이 후단보다 하나 앞에 있으면 포화 상태</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span>(<span class="params">self, item</span>):</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isFull(): <span class="comment"># 포화상태가 아니면</span></span><br><span class="line">            self.rear=(self.rear+<span class="number">1</span>)%MAX_QSIZE <span class="comment"># 후단 회전</span></span><br><span class="line">            self.items[self.rear]=item  <span class="comment">#후단 위치에 삽입, 초기 상태에서 맨 처음 삽입되는 위치는 0번(후단)이 아니고 그 다음 1번</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty(): <span class="comment"># 공백상태가 아니면</span></span><br><span class="line">            self.front=(self.front+<span class="number">1</span>)%MAX_QSIZE <span class="comment"># 전단 회전</span></span><br><span class="line">            self.items[self.front]=<span class="number">0</span> <span class="comment"># 전단 위치의 항목 반환</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            <span class="keyword">return</span> self.items[(self.front+<span class="number">1</span>)%MAX_QSIZE]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span>(self.rear- self.front+MAX_QSIZE)%MAX_QSIZE</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span> <span class="comment">#배열 원소 전체를 차례로 화면에 출력</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.items[:]:</span><br><span class="line">            <span class="built_in">print</span>(i,end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    q=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"원형 큐의 크기(양의정수):"</span>))</span><br><span class="line">    MAX_QSIZE = q</span><br><span class="line">    queue = CircularQueue()</span><br><span class="line">    n=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"연산의 개수(양의정수):"</span>))</span><br><span class="line">    count=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> count&lt;=n:</span><br><span class="line">        instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류 등을 입력하세요:"</span>)</span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"I"</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue.isFull():</span><br><span class="line">                a, b, = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                queue.enqueue(b)</span><br><span class="line">            <span class="keyword">if</span> queue.isFull():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"overflow"</span>, end=<span class="string">' '</span>) <span class="comment"># 포화 상태에서 삽입 시도 시 "overflow" 출력 후 프로그램 종료</span></span><br><span class="line">                queue.display()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> queue.isEmpty():</span><br><span class="line">                queue.dequeue()</span><br><span class="line">            <span class="keyword">if</span> queue.isEmpty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"underflow"</span>) <span class="comment"># 공백 상태에서 삭제 시도 시 "underflow" 출력 후 프로그램 종료</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span>:</span><br><span class="line">            queue.display()</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">        count=count+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="전단front과-후단rear에서-모두-삽입과-삭제가-가능한-큐는-덱deque이라고-합니다.">전단(front)과 후단(rear)에서 모두 삽입과 삭제가 가능한 큐는 덱(deque)이라고 합니다.</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 헤드 노드와 테일 노드가 없는 이중연결리스트를 사용하여 구현한 덱(deque) (더미노드 없는 버젼)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, item, prev=<span class="literal">None</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.data = item</span><br><span class="line">        self.prev = prev</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dlinked_deque</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.front=<span class="literal">None</span></span><br><span class="line">        self.rear=<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.front == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addFront</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">if</span>(self.isEmpty()):</span><br><span class="line">            node = DNode(item, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            self.front=node</span><br><span class="line">            self.rear=node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DNode(item, <span class="literal">None</span>, self.front)</span><br><span class="line">            self.front.prev=node</span><br><span class="line">            self.front=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addRear</span>(<span class="params">self,item</span>):</span></span><br><span class="line">        <span class="keyword">if</span>(self.isEmpty()):</span><br><span class="line">            node = DNode(item, <span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">            self.front=node</span><br><span class="line">            self.rear=node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = DNode(item, self.rear, <span class="literal">None</span>)</span><br><span class="line">            self.rear.<span class="built_in">next</span>=node</span><br><span class="line">            self.rear=node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteFront</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            data=self.front.data</span><br><span class="line">            self.front=self.front.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> self.front==<span class="literal">None</span>:</span><br><span class="line">                self.rear=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.front.prev=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteRear</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            data=self.rear.data</span><br><span class="line">            self.rear=self.rear.prev</span><br><span class="line">            <span class="keyword">if</span> self.rear==<span class="literal">None</span>:</span><br><span class="line">                self.front=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.rear.<span class="built_in">next</span>=<span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printt</span>(<span class="params">self</span>):</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        p = self.front</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="keyword">if</span> p != self.rear:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">' '</span> + <span class="built_in">str</span>(p.data), end=<span class="string">' '</span>)</span><br><span class="line">                    flag = flag <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">str</span>(p.data), end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">                p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">' '</span> + <span class="built_in">str</span>(p.data))</span><br><span class="line">                    flag = flag <span class="keyword">and</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">str</span>(p.data))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    dq = dlinked_deque()</span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"연산의 개수:"</span>))</span><br><span class="line">    <span class="keyword">while</span> count &lt;= n:</span><br><span class="line"></span><br><span class="line">        instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류(AF, AR, DF, DR, P)와 양의 정수를 입력하세요:"</span>)</span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">"A"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] ==<span class="string">"F"</span>:</span><br><span class="line">            a, b= instruction.split(<span class="string">" "</span>)</span><br><span class="line">            dq.addFront(<span class="built_in">int</span>(b))</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"A"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"R"</span>:</span><br><span class="line">            a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">            dq.addRear(<span class="built_in">int</span>(b))</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"F"</span>:</span><br><span class="line">            <span class="keyword">if</span> dq.isEmpty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"underflow"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dq.isEmpty():</span><br><span class="line">                dq.deleteFront()</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"D"</span> <span class="keyword">and</span> instruction[<span class="number">1</span>] == <span class="string">"R"</span>:</span><br><span class="line">            <span class="keyword">if</span> dq.isEmpty():</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"underflow"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dq.isEmpty():</span><br><span class="line">                dq.deleteRear()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"P"</span>:</span><br><span class="line">            dq.printt()</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">        count = count + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>우선순위 큐(priority queue)는 모든 데이터가 우선순위를 가지고 입력 순서와 상관없이 우선순위가 높은 데이터가 먼저 출력되는 큐입니다. (그냥 큐의 경우 먼저 삽입된 항목이 우선순위가 더 높고, 그냥 스택의 경우 가장 마지막으로 삽입된 항목이 가장 높은 우선 순위를 가지는 바 스택이나 큐도 일종의 우선순위큐입니다. )</p>
<h2 id="트리tree">4. 트리(Tree)</h2>
<p>트리는 계층적인 자료의 표현에 적합한 자료구조로 일반적인 트리와 모든 노드가 2개의 서브 트리를 갖는 이진트리로 구분됩니다.</p>
<p>이진 트리의 경우 노드의 개수가 n개이면 간선의 개수는 n-1개 이며 높이가 h라면 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex" xmlns="http://www.w3.org/2000/svg" width="6.137ex" height="2.117ex" role="img" focusable="false" viewBox="0 -853.7 2712.7 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g></g><g data-mml-node="mo" transform="translate(1212.5,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2212.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>개의 노드를 갖습니다. 예를 들어 7개의 노드를 일렬로 늘어 놓으면 트리의 높이가 최대인 7이 되나 7개의 노드를 루트부터 빼곡히 채우면 높이 3인 트리를 만들 수 있습니다. 이진트리는 배열표현법(노드 i의 부모 인덱스=i/2, 왼쪽 자식 노드 인덱스=2i, 오른쪽 자식 노드 인덱스=2i+1)과 링크표현법(노드에 왼쪽 자식, 오른쪽 자식 레퍼런스를 포함)을 통해 구현할 수 있습니다. 그리고 루트(맨 위 시작 노드)에서 왼쪽 서브트리 그리고 오른쪽 서브트리를 순회하는 전위 순회(preorder traversal, VLR), 왼쪽 서브트리부터 루트 오른쪽 서브트리를 순회하는 중위 순회(inorder traversal, LVR), 왼쪽 서브트리부터 오른쪽 서브트리를 거쳐 루트를 순회하는 후위 순회(postorder traversal, LRV), 그리고 레벨 순회 등을 통해 순회합니다.</p>
<h3 id="힙heap-트리">힙(Heap) 트리</h3>
<p>완전이진트리 기반의 자료구조로 가장 큰(또는 작은) 값을 빠르게 찾아내도록 만들어진 자료 구조입니다. 최대힙(max heap)은 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전이진트리이고 최소 힙(min heap)은 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전이진트리입니다. 힙의 삽입 연산은 상향식 힙, 힙의 삭제 연산(최대힙에서 삭제시 항상 루트가 삭제됨)은 하향식 힙 방법을 활용합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 배열을 이용한 순차트리 형식으로 힙을 저장</span></span><br><span class="line"><span class="comment"># 최대힙</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.heap=[]</span><br><span class="line">        self.heap.append(<span class="number">0</span>) <span class="comment">#연산 효율을 위해 배열 인덱스 0 위치는 사용하지 아니하고 비워둠</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> <span class="built_in">len</span>(self.heap)-<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="keyword">return</span> self.size()==<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Parent</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> self.heap[i//<span class="number">2</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Left</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> self.heap[i*<span class="number">2</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Right</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> self.heap[i*<span class="number">2</span>+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, n</span>):</span> <span class="comment">#키를 힙에 삽입하고 0을 출력</span></span><br><span class="line">        self.heap.append(n)</span><br><span class="line">        i=self.size()</span><br><span class="line">        <span class="keyword">while</span> (i !=<span class="number">1</span> <span class="keyword">and</span> n&gt;self.Parent(i)):</span><br><span class="line">            self.heap[i]=self.Parent(i)</span><br><span class="line">            i=i//<span class="number">2</span></span><br><span class="line">        self.heap[i]=n</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self</span>):</span> <span class="comment"># 힙에서 삭제(루트에 저장된 키가 삭제)하여 반환된 키를 출력</span></span><br><span class="line">        parent=<span class="number">1</span></span><br><span class="line">        child=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isEmpty():</span><br><span class="line">            hroot=self.heap[<span class="number">1</span>]</span><br><span class="line">            last=self.heap[self.size()]</span><br><span class="line">            <span class="keyword">while</span> (child &lt;= self.size()):</span><br><span class="line">                <span class="keyword">if</span> child&lt;self.size() <span class="keyword">and</span> self.Left(parent)&lt;self.Right(parent):</span><br><span class="line">                    child +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> last &gt;= self.heap[child]:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                self.heap[parent]=self.heap[child]</span><br><span class="line">                parent=child</span><br><span class="line">                child *=<span class="number">2</span></span><br><span class="line"></span><br><span class="line">            self.heap[parent]=last</span><br><span class="line">            self.heap.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> hroot</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'  '</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.heap[<span class="number">1</span>:]: <span class="comment">#힙의 내용을 이진트리의 레벨순서대로 인쇄, 같은 레벨의 노드들은 왼쪽에서 오른쪽으로 방문</span></span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    heap=MaxHeap()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="keyword">and</span> heap.size()&lt;<span class="number">100</span>:</span><br><span class="line">        instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류(i와 1 이상의 정수, d, p, q)를 입력하세요:"</span>)</span><br><span class="line">        <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">'i'</span>:</span><br><span class="line">            a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">            heap.insert(<span class="built_in">int</span>(b))</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"d"</span>:</span><br><span class="line">            <span class="built_in">print</span>(heap.delete())</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"p"</span>:</span><br><span class="line">            heap.display()</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">        <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"q"</span>: <span class="comment">#프로그램 종료</span></span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 키들이 미리 한꺼번에 주어지며 이들을 주어진 순서대로 초기 배열에 저장</span></span><br><span class="line"><span class="comment"># 초기 배열에 저장된 키들을 상향식으로 재배치하여 힙 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bottom_up_Heap</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.heap=[]</span><br><span class="line">        self.heap.append(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Left</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> <span class="built_in">int</span>(self.heap[i*<span class="number">2</span>])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Right</span>(<span class="params">self, i</span>):</span> <span class="keyword">return</span> <span class="built_in">int</span>(self.heap[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heap2</span>(<span class="params">self,k,n</span>):</span></span><br><span class="line">        self.heap=self.heap+k</span><br><span class="line">        i=<span class="built_in">int</span>(n)</span><br><span class="line">        p = i // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> p &gt;= <span class="number">1</span>:</span><br><span class="line">            parent = p</span><br><span class="line">            child = p * <span class="number">2</span></span><br><span class="line">            p_node = <span class="built_in">int</span>(self.heap[p])</span><br><span class="line">            <span class="keyword">while</span> child &lt;= i:</span><br><span class="line">                <span class="keyword">if</span> child &lt; i <span class="keyword">and</span> self.Left(parent) &lt; self.Right(parent):</span><br><span class="line">                    child += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> p_node &lt; <span class="built_in">int</span>(self.heap[child]):</span><br><span class="line">                    self.heap[parent] = self.heap[child]</span><br><span class="line">                    parent = child</span><br><span class="line">                    child *= <span class="number">2</span></span><br><span class="line">            self.heap[parent] = p_node</span><br><span class="line">            p=p-<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'  '</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.heap[<span class="number">1</span>:]:</span><br><span class="line">            <span class="built_in">print</span>(i, end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    heap = bottom_up_Heap()</span><br><span class="line">    num_key, key_contents = <span class="built_in">input</span>(<span class="string">'키 개수(100개 미만):'</span>), <span class="built_in">input</span>(<span class="string">'키 내용(중복이 없는 1이상의 정수):'</span>)</span><br><span class="line">    data = key_contents.split(<span class="string">' '</span>)</span><br><span class="line">    heap.heap2(data,num_key)</span><br></pre></td></tr></table></figure>
<h3 id="탐색-트리">탐색 트리</h3>
<ul>
<li>탐색트리란 탐색을 위한 트리 기반의 자료구조입니다.</li>
<li>그리고 이진탐색트리란 효율적인 탐색을 위한 이진트리 기반의 자료구조로 모든 노드는 유일한 키를 가집니다. 또한 왼쪽 서브트리의 키들은 루트의 키보다 작고 오른쪽 서브트리의 키들은 루트의 키보다 크며 왼쪽과 오른쪽 서브트리 역시 이진탐색트리입니다.</li>
<li>탐색트리의 탐색 연산은 키를 이용하여 부모노드의 키보다 작으면 왼쪽 자식부터, 크다면 오른쪽 자식부터 반복하여 탐색합니다.</li>
<li>탐색트리의 삽입 연산은 탐색에 실패한 위치가 곧 노드를 삽입해야 할 위치가 됩니다.</li>
<li>삭제 연산은 삭제하려는 노드가 단말 노드일 경우 그 노드만 삭제하고, 삭제하려는 노드가 왼쪽이나 오른쪽 서브 트리중 하나만 가지고 있는 경우 삭제 노드의 자식 노드를 부모 노드에 연결하며, 삭제하려는 노드가 양쪽 모두 서브트리를 가지고 있는 경우 삭제할 위치에 왼쪽 서브트리의 가장 큰 노드나 오른쪽 서브트리의 가장 작은 노드 즉 가장 비슷한 값을 가진 노드를 삭제 위치로 가져옵니다.</li>
<li>이진탐색트리의 성능 즉 탐색, 삽입, 삭제 연산의 시간은 트리의 높이에 비례합니다.</li>
<li>AVL 트리(균형이진탐색트리)는 트리 높이를 조정하여 시간복잡도를 개선한 것입니다. AVL 트리는 모든 노드에서 왼쪽 서브트리와 오른쪽 서브트리의 높이 차가 1을 넘지 않는 이진탐색트리이며 모든 노드의 균형 인수는 0이나 +1, -1이 되어야 합니다. 삭입과 삭제 시 균형 상태가 깨질 수 있기에 LL 회전, LR 회전, RR 회전, RL 회전의 방법을 통해 재균형을 맞춥니다.</li>
</ul>
<p><strong>AVL 트리의 균형이 깨지는 4가지 경우</strong></p>
<p>-삽입된 노드 N으로부터 가장 가까우면서 균형 인수가 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"></path></g></g></g></svg></mjx-container></span> 2가 된 조상 노드가 A라면</p>
<ol type="1">
<li>LL타입: N이 A의 왼쪽서브트리의 왼쪽서브트리에 삽입</li>
<li>LR타입: N이 A의 왼쪽서브트리의 오른쪽서브트리에 삽입</li>
<li>RR타입: N이 A의 오른쪽서브트리의 오른쪽서브트리에 삽입</li>
<li>RL타입: N이 A의 오른쪽서브트리의 왼쪽서브트리에 삽입</li>
</ol>
<p><strong>각 타입별 재균형 방법</strong></p>
<ol type="1">
<li>LL회전: A부터 N까지의 경로상 노드의 오른쪽 회전</li>
<li>LR회전: A부터 N까지의 경로상 노드의 왼쪽-오른쪽 회전</li>
<li>RR회전: A부터 N까지의 경로상 노드의 왼쪽 회전</li>
<li>RL회전: A부터 N까지의 경로상 노드의 오른쪽-왼쪽 회전</li>
</ol>
<p>예시</p>
<ul>
<li>Empty인 AVL 트리에 차례로 key 값 75, 80, 85, 20, 10, 50, 30, 40, 70, 90을 삽입하면서 최종 AVL 트리가 생성되는 과정</li>
</ul>
<p><strong>삽입 방법</strong></p>
<ol type="1">
<li>삽입하는 키가 부모노드의 키보다 작을 경우</li>
</ol>
<ul>
<li>왼쪽 자식노드가 비어있다면 왼쪽 자식노드에 삽입</li>
<li>왼쪽 자식노드가 차있다면 왼쪽 자식노드를 부모노드로 하여 다시금 삽입 프로세스</li>
</ul>
<ol start="2" type="1">
<li>삽입하는 키가 부모노드의 키보다 클 경우</li>
</ol>
<ul>
<li>오른쪽 자식노드가 비어있다면 오른쪽 자식노드에 삽입</li>
<li>오른쪽 자식노드가 차있다면 오른쪽 자식노드를 부모노드로 하여 다시금 삽입 프로세스</li>
</ul>
<p>삽입 노드로부터 균형인수가 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.76ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 778 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="B1" d="M56 320T56 333T70 353H369V502Q369 651 371 655Q376 666 388 666Q402 666 405 654T409 596V500V353H707Q722 345 722 333Q722 320 707 313H409V40H707Q722 32 722 20T707 0H70Q56 7 56 20T70 40H369V313H70Q56 320 56 333Z"></path></g></g></g></svg></mjx-container></span> 2가 된 가장 가까운 조상 노드까지 회전합니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLmap</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self, key</span>):</span></span><br><span class="line">            self.key = key</span><br><span class="line">            self.left = <span class="literal">None</span></span><br><span class="line">            self.right = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.root=<span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span>(<span class="params">self, root</span>):</span> <span class="comment">#높이</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(self.height(root.left), self.height(root.right))+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height_dif</span>(<span class="params">self, root</span>):</span> <span class="comment"># 균형인수</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(self.height(root.left)- self.height(root.right))</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateLL</span>(<span class="params">self, a</span>):</span> <span class="comment"># LL회전</span></span><br><span class="line">        b = a.left</span><br><span class="line">        a.left = b.right</span><br><span class="line">        b.right = a</span><br><span class="line">        <span class="keyword">return</span> b <span class="comment"># 새로운 루트 b를 반환</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRR</span>(<span class="params">self, a</span>):</span> <span class="comment"># RR회전</span></span><br><span class="line">        b = a.right</span><br><span class="line">        a.right = b.left</span><br><span class="line">        b.left = a</span><br><span class="line">        <span class="keyword">return</span> b </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateLR</span>(<span class="params">self, a</span>):</span> <span class="comment"># LR회전</span></span><br><span class="line">        b=a.left</span><br><span class="line">        a.left = self.rotateRR(b)</span><br><span class="line">        <span class="keyword">return</span> self.rotateLL(a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRL</span>(<span class="params">self, a</span>):</span> <span class="comment"># RL회전</span></span><br><span class="line">        b = a.right</span><br><span class="line">        a.right = self.rotateLL(b)</span><br><span class="line">        <span class="keyword">return</span> self.rotateRR(a)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reBalance</span>(<span class="params">self, root</span>):</span>  <span class="comment"># 재균형</span></span><br><span class="line">        hDiff = self.height_dif(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hDiff&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> self.height_dif(root.left)&gt;<span class="number">0</span>:</span><br><span class="line">                root = self.rotateLL(root)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = self.rotateLR(root)</span><br><span class="line">        <span class="keyword">elif</span> hDiff&lt;-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> self.height_dif(root.right)&lt;<span class="number">0</span>:</span><br><span class="line">                root = self.rotateRR(root)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = self.rotateRL(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert_avl</span>(<span class="params">self, root, node</span>):</span> <span class="comment"># AVL 방식으로 삽입</span></span><br><span class="line">        <span class="keyword">if</span> node.key &lt; root.key:</span><br><span class="line">            <span class="keyword">if</span> root.left != <span class="literal">None</span>:</span><br><span class="line">                root.left= self.insert_avl(root.left, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left = node</span><br><span class="line">            <span class="keyword">return</span> self.reBalance(root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> node.key &gt; root.key:</span><br><span class="line">            <span class="keyword">if</span> root.right != <span class="literal">None</span>:</span><br><span class="line">                root.right= self.insert_avl(root.right, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right = node</span><br><span class="line">            <span class="keyword">return</span> self.reBalance(root)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"중복된 키 에러"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, key</span>):</span>  <span class="comment"># 트리에 삽입</span></span><br><span class="line">        n= self.Node(key)</span><br><span class="line">        <span class="keyword">if</span> self.root==<span class="literal">None</span>:</span><br><span class="line">            self.root=n</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new = self.insert_avl(self.root, n)</span><br><span class="line">            self.root = new</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, root</span>):</span> <span class="comment"># 레벨순회 표시</span></span><br><span class="line">        q=[]</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(q)!=<span class="number">0</span>:</span><br><span class="line">            t=q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(t.key), <span class="string">' '</span>, end=<span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">if</span> t.left != <span class="literal">None</span>:</span><br><span class="line">                q.append(t.left)</span><br><span class="line">            <span class="keyword">if</span> t.right != <span class="literal">None</span>:</span><br><span class="line">                q.append(t.right)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    node = [<span class="number">75</span>, <span class="number">80</span>, <span class="number">85</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">70</span>, <span class="number">90</span>] <span class="comment"># 75, 80, 85, 20, 10, 50, 30, 40, 70, 90</span></span><br><span class="line">    <span class="built_in">map</span> = AVLmap()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> node:</span><br><span class="line">        <span class="built_in">map</span>.insert(i)</span><br><span class="line">    <span class="built_in">map</span>.display(<span class="built_in">map</span>.root)</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 50을 삽입할 때의 상황</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[75, 80, 85, 20, 10]까지 삽입되었을 때 맨 위 루트 노드의 키 값은 80입니다. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">50이 삽입되면 insert 함수를 거쳐 50을 키값으로 갖는 신규노드 생성되고 본 노드와 루트노드(키 값 80)가 insert_avl 함수 인자로 들어갑니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">insert_avl 함수에서 루트노드 키보다 신규노드 키가 작고 루트노드의 왼쪽 자식노드가 이미 차있으므로(키 값 20의 노드) 684줄에 따라 루트노드의 왼쪽 자식노드(키 값 20의 노드)와 신규노드를 다시금 insert_avl 함수 인자로 돌립니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">신규노드(키 값 50)가 루트노드의 왼쪽 자식노드(키 값 20)노드보다 키 값이 크고 루트노드의 왼쪽 자식노드의 오른쪽 자식노드(키 값 75의 노드, 줄여서 왼오자식노드라고 하겠습니다)가 존재하므로 691줄에 따라 신규노드(키 값 50)와 왼오자식노드(키 값 75)를 insert_avl 함수로 돌립니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">신규노드의 키 값은 왼오자식노드의 키 값보다 작고 왼오자식노드의 왼쪽 자식 노드는 존재하지 않는바, 신규노드는 왼오자식노드의 왼쪽자식노드에 위치하게됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이후 694줄에 의해 왼오자식노드(키 값 75)가 reBalance 함수에 들어가고 hDiff(균형인수)가 절대값 1을 초과하지 않아 키 값 75의 노드가 반환됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이 키 값 75 노드는 키 값 20 노드의 오른쪽 자식 노드가 됩니다. 이후 694줄에 의해 키 값 20 노드를 인자로  reBalance 함수가 돌아가고 균형인수가 절대값 1을 초과하지 않아 키 값 20의 노드가 반환됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이 키 값 20 노드는 키 값 80 노드의 왼쪽 자식 노드가 됩니다. 이후 687줄에 의해 키 값 80 노드를 인자로 reBalance 함수가 돌아가고 균형인수 절대값이 2이므로 669줄로 가게됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이 때 키 값 80노드의 왼쪽 자식 노드인 키 값 20 노드의 균형인수가 -1이므로 673줄에 따라 키 값 80노드를 인자로 하여 LR회전이 이루어집니다(rotateLR 함수)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**LR 회전 656줄 (rotateLR 함수)**</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def rotateLR(self, a): # LR회전</span></span><br><span class="line"><span class="string">        b=a.left</span></span><br><span class="line"><span class="string">        a.left = self.rotateRR(b)</span></span><br><span class="line"><span class="string">        return self.rotateLL(a)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">키 값 80 노드의 왼쪽 자식 노드인 키 값 20 노드는 b가 됩니다.</span></span><br><span class="line"><span class="string">이 b를 인자로 RR회전(rotateRR 함수)를 하여 반환된 값이 키 값 80 노드의 왼쪽 자식 노드가 됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def rotateRR(self, a): # RR회전</span></span><br><span class="line"><span class="string">        b = a.right</span></span><br><span class="line"><span class="string">        a.right = b.left</span></span><br><span class="line"><span class="string">        b.left = a</span></span><br><span class="line"><span class="string">        return b </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">키 값 20 노드를 인자로 rotateRR 함수를 돌릴시 </span></span><br><span class="line"><span class="string">키 값 20 노드의 오른쪽 자식 노드인 키 값 75 노드는 b가 됩니다.</span></span><br><span class="line"><span class="string">키 값 20 노드의 오른쪽 자식 노드는 키 값 75 노드의 왼쪽 자식노드인 키 값 50 노드가 됩니다. *************************</span></span><br><span class="line"><span class="string">키 값 75 노드의 왼쪽 자식노드는 키 값 20 노드가 됩니다.</span></span><br><span class="line"><span class="string">키 값 75 노드를 반환합니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">따라서 키 값 80 노드의 왼쪽 자식 노드는 키 값 75노드가 됩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">마지막으로 754줄에 따라 키 값 80 노드를 인자로 LL 회전(rotateLL 함수)을 거칩니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def rotateLL(self, a): # LL회전</span></span><br><span class="line"><span class="string">        b = a.left</span></span><br><span class="line"><span class="string">        a.left = b.right</span></span><br><span class="line"><span class="string">        b.right = a</span></span><br><span class="line"><span class="string">        return b # 새로운 루트 b를 반환</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">키 값 80 노드의 왼쪽 자식 노드인 키 값 75 노드는 b가 됩니다.</span></span><br><span class="line"><span class="string">b의 오른쪽 자식 노드가 없으므로 키 값 80 노드의 왼쪽 자식 노드도 존재하지 않습니다.</span></span><br><span class="line"><span class="string">키 값 80노드는 키 값 75노드의 오른쪽 자식 노드가 됩니다.</span></span><br><span class="line"><span class="string">키 값 75 노드를 반환합니다.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">이로써 회전이 마무리 됩니다. (새로운 루트 노드는 키 값 75 노드)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/84167756/151522275-d7fda4dc-58d1-4a00-a8cb-f48b9714692a.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151522324-2bb93c1a-9182-40d6-8fe5-1339c4c87222.png"></p>
<p>다음의 AVL 트리에서 key 값 75를 삭제한 다음, 85를 삭제한 후의 AVL 트리</p>
<p><img src="https://user-images.githubusercontent.com/84167756/151522359-ef5ad907-22f6-4a73-a4ba-340838762c40.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151522413-fcdecce2-fb8e-47bc-a010-a370d02c438b.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151522423-278e4522-1f61-4dcf-a8f5-da71399393b2.png"></p>
<h2 id="해시테이블">5. 해시테이블</h2>
<p>키와 값으로 쌍으로 이루어진 데이터의 키를 간단한 함수를 사용해 변환한 값을 배열의 인덱스로 이용하여 항목을 저장하는 것을 해싱(Hashing), 해싱에 사용되는 함수를 해시함수(Hash Function), 해시함수가 계산한 값을 해시값(Hash value), 항목이 해시값에 따라 저장되는 배열을 해시테이블(Hash Table)이라고 합니다.</p>
<p>AVL 트리의 수행시간인 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="8.346ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3689 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(3300,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>보다 좋은 빠른 연산을 위해, 키와 1차원 리스트의 인덱스의 관계를 이용하여 키(항목)를 저장하되 키를 배열의 인덱스로 그대로 사용하면 메모리 낭비가 심해질 수 있으므로 해싱을 활용합니다. 이 결과 키로 탐색할 경우 그에 대응하는 값을 바로 찾을 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 폐쇄주소지정방법 해시테이블, 체이닝</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 폐쇄주소방식의 충돌해결 방법은 키에 대한 해시값에 대응되는 곳에만 키를 저장하고 충돌이 발생한 키들은 한 위치에 모여 저장합니다.</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Chaining</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, link</span>):</span></span><br><span class="line">            self.key=key</span><br><span class="line">            self.<span class="built_in">next</span>=link</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.M=size             <span class="comment">#헤시테이블은 크기가 M인 배열</span></span><br><span class="line">        self.a=[<span class="literal">None</span>]*size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">return</span> key % self.M  <span class="comment"># 해시함수</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key</span>):</span> <span class="comment">#삽입시 충돌이 발생하는 경우, 해당 버켓 리스트의 맨 앞에 삽입</span></span><br><span class="line">        i=<span class="built_in">int</span>(self.<span class="built_in">hash</span>(key))</span><br><span class="line">        self.a[i]=self.Node(key,self.a[i])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        i = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        p = self.a[i]</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> key == p.key:</span><br><span class="line">                p.key=p.<span class="built_in">next</span>.key</span><br><span class="line">                <span class="built_in">print</span>(n)          </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#탐색 또는 삭제할 때, 키가 존재하면 리스트에서 해당 키가 저장된 순서(1부터 시작)을 인쇄하고 없다면 0을 인쇄(해시테이블 주소가 아닌 리스트에서의 순위)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span> <span class="comment">#해당 키가 해시테이블에 존재하는지 탐색</span></span><br><span class="line">        i=self.<span class="built_in">hash</span>(key)</span><br><span class="line">        p=self.a[i]</span><br><span class="line">        n=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p!=<span class="literal">None</span>:</span><br><span class="line">            n+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> key ==p.key:</span><br><span class="line">                <span class="built_in">print</span>(n)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            p=p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> p==<span class="literal">None</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_table</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.M):</span><br><span class="line">            p = self.a[i]</span><br><span class="line">            <span class="keyword">while</span> p != <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(p.key, end=<span class="string">' '</span>)</span><br><span class="line">                p=p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">        M=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"해시테이블의 사이즈:"</span>))</span><br><span class="line">        size=M</span><br><span class="line">        <span class="built_in">hash</span>=Chaining(size)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류 등을 입력하여 주세요:"</span>)</span><br><span class="line">            <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">'i'</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.put(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"s"</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.get(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">'d'</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.delete(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"p"</span>:</span><br><span class="line">                <span class="built_in">hash</span>.print_table()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"e"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 개방주소법 해시테이블 - 선형조사법</span></span><br><span class="line"><span class="comment"># 개방주소방식은 해시테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 empty 원소에 저장 (선형조사, 이차조사, 이중해싱)</span></span><br><span class="line"><span class="comment"># 선형조사는 순차탐색으로 empty 원소를 찾아 충돌된 키를 저장하므로 군집화 현상이 발생</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearProbing</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.M=size</span><br><span class="line">        self.a=[<span class="literal">None</span>]*size</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.M):</span><br><span class="line">            <span class="keyword">if</span> self.a[i]==<span class="literal">None</span>:</span><br><span class="line">                self.a[i]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">            <span class="keyword">return</span> key % self.M</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key</span>):</span> <span class="comment"># 키를 삽입하였을 때, 저장된 주소(배열 인덱스)를 인쇄하고 충돌 있을시 충돌 횟수만큼 C를 인쇄한 후, 삽입에 성공한 주소를 인쇄</span></span><br><span class="line">        initial_position = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        i=initial_position</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.a[i] == <span class="number">0</span>:</span><br><span class="line">                self.a[i] = key</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            i=(initial_position+j)%self.M</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'C'</span>, end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> i == initial_position:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span> <span class="comment">#탐색한 키가 테이블에 존재할 경우, 키가 저장된 주소와 값을 인쇄</span></span><br><span class="line">        initial_position = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        i = initial_position</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> self.a[i] !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.a[i]==key:</span><br><span class="line">                <span class="built_in">print</span>(i, self.a[i])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            i=(initial_position+j) % self. M</span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == initial_position:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'-1'</span>)</span><br><span class="line">        <span class="keyword">if</span> self.a[i]==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">        M=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"해시테이블의 사이즈:"</span>))</span><br><span class="line">        size=M</span><br><span class="line">        <span class="built_in">hash</span>=LinearProbing(size)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류 등을 입력하여 주세요:"</span>)</span><br><span class="line">            <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">'i'</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.put(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"s"</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.get(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"e"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 개방주소법 해시테이블 - 이중해싱</span></span><br><span class="line"><span class="comment"># 이중해싱은 2개의 해시함수를 사용하며 하나는 기본적인 해시함수로 키를 해시테이블의 인덱스로 변환하고, 제2함수는 충돌 발생 시 다음 위치를 위한 점프 크기를 정함, 모든 군집화 문제를 해결</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleHashing</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self.M=size</span><br><span class="line">        self.a=[<span class="literal">None</span>]*size</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.M):</span><br><span class="line">            <span class="keyword">if</span> self.a[i]==<span class="literal">None</span>:</span><br><span class="line">                self.a[i]=<span class="number">0</span></span><br><span class="line">        self.N=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hash</span>(<span class="params">self, key</span>):</span></span><br><span class="line">            <span class="keyword">return</span> key % self.M <span class="comment"># 첫 번째 해시 함수</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, q</span>):</span></span><br><span class="line">        initial_position = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        i=initial_position</span><br><span class="line">        d = q-(key%q) <span class="comment"># 두 번째 해시 함수</span></span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.a[i] == <span class="number">0</span>:</span><br><span class="line">                self.a[i] = key</span><br><span class="line">                self.N+=<span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'C'</span>, end=<span class="string">''</span>)</span><br><span class="line">            i=(initial_position + j*d)%self.M</span><br><span class="line">            <span class="keyword">if</span> self.N &gt; self.M:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        initial_position = self.<span class="built_in">hash</span>(key)</span><br><span class="line">        i = initial_position</span><br><span class="line">        d = q-(key%q)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> self.a[i] !=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self.a[i]==key:</span><br><span class="line">                <span class="built_in">print</span>(i, self.a[i])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            j +=<span class="number">1</span></span><br><span class="line">            i=(initial_position+j*d) % self.M</span><br><span class="line">        <span class="keyword">if</span> self.a[i] == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'-1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_hashtable</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.M):</span><br><span class="line">            <span class="built_in">print</span>(self.a[i], end=<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">        M , q=<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"해시테이블의 사이즈:"</span>)), <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">"해시테이블 사이즈보다 조금 작은 소수:"</span>))</span><br><span class="line">        size=M</span><br><span class="line">        <span class="built_in">hash</span>=DoubleHashing(size)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            instruction = <span class="built_in">input</span>(<span class="string">"연산의 종류 등을 입력하여 주세요:"</span>)</span><br><span class="line">            <span class="keyword">if</span> instruction[<span class="number">0</span>] == <span class="string">'i'</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.put(<span class="built_in">int</span>(b), q)</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"s"</span>:</span><br><span class="line">                a, b = instruction.split(<span class="string">" "</span>)</span><br><span class="line">                <span class="built_in">hash</span>.get(<span class="built_in">int</span>(b))</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"p"</span>:</span><br><span class="line">                <span class="built_in">hash</span>.print_hashtable()</span><br><span class="line">                <span class="built_in">print</span>()</span><br><span class="line">            <span class="keyword">elif</span> instruction[<span class="number">0</span>] == <span class="string">"e"</span>:</span><br><span class="line">                <span class="built_in">hash</span>.print_hashtable()</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h2 id="알고리즘">&lt;정렬&gt; 알고리즘</h2>
<ul>
<li>정렬은 데이터를 순서대로 재배열하는 것으로 가장 기본적이고 중요한 알고리즘입니다.</li>
<li>레코드는 정렬시켜야 될 대상으로 여러 개의 필드(field)로 이루어져 있으며 정렬 키(sort key)는 정렬의 기준이 되는 필드입니다.</li>
</ul>
<p>간단한 정렬방법은 아래와 같습니다.</p>
<ul>
<li>선택 정렬(selection sort): 리스트에서 가장 작은 숫자를 선택하여 빈 리스트의 맨 뒤로 이동하는 작업을 반복합니다.</li>
<li>삽입 정렬(insertion sort): 정렬되어 있는 부분에 새로운 레코드를 올바른 위치에 삽입하는 과정을 반복합니다. 삽입으로 인해 여러 데이터 항목들의 이동이 일어납니다.</li>
<li>버블 정렬(bubble sort): 인접한 2개의 레코드를 비교하여 순서대로 서로 교환하는 과정을 리스트의 전체에 대해 수행(스캔)하며 이를 통해 오른쪽 끝에 가장 큰 레코드가 위치한다면 끝으로 이동한 레코드를 제외하고 다시 스캔을 반복합니다.</li>
</ul>
<p>아래는 보다 효율적인 고급 정렬 방법입니다.</p>
<h3 id="쉘-정렬">쉘 정렬</h3>
<ul>
<li>삽입정렬을 어느 정도 정렬된 리스트에서 할 경우 대단히 빠르므로 리스트를 일정 간격의 부분 리스트로 나누고 간격이 1이 될 때까지 간격을 줄이는 행위를 반복하는 정렬 방법입니다(간격을 줄일수록 부분 리스트의 수는 더 작아지고 각 부분리스트는 더 커집니다).</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151475486-19b887a2-12f1-43b1-8a1b-832c32794e9d.png"></p>
<h3 id="힙-정렬">힙 정렬</h3>
<ul>
<li>리스트를 최대힙으로 만들고 최대힙을 정렬된 리스트로 만듭니다.</li>
<li>구체적으로 최대힙에서 루트를 힙의 가장 마지막 노드와 교환한 후 downheap 연산(루트와 두 자식 비교 후 승자와 교환)하는 것을 반복 진행하여 정렬된 리스트로 만듭니다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151475966-25c9ff18-5f40-413c-b174-0db2e3113c8a.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151476089-17395489-5ec1-4bd0-85b7-1fc5a4cc67ca.png"></p>
<h3 id="병합-정렬">병합 정렬</h3>
<ul>
<li>분할 정복(divide and conquer) 방법을 사용하며 문제를 보다 작은 2개의 문제로 분리하고 각 문제를 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151477849-47262e97-9455-4b4a-a1b1-92ddfe193736.png"></p>
<h3 id="퀵-정렬">퀵 정렬</h3>
<ul>
<li>퀵 정렬의 방법은 우선 피벗을 선정한 후 피벗을 기준으로 좌측에서부터 우측 방향으로 (low)를 피벗보다 큰 항목까지 이동, 우측에서부터 좌측 방향으로 (high)를 피벗보다 작은 항목까지 이동, 그 후 low와 high의 항목을 교체하여 다시 진행하고 low와 high가 역전되면 종료됩니다. 종료시 피벗과 (high)위치의 항목을 교환합니다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151489576-75b88e35-749a-47a8-8562-76ece8f72ab2.png"></p>
<h2 id="간단한-탐색-알고리즘">간단한 탐색 알고리즘</h2>
<ul>
<li>순차탐색(sequential search): 정렬되지 않은 배열을 처음부터 마지막까지 하나씩 검사합니다.</li>
<li>이진 탐색(binary search): 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄여가며 탐색을 진행합니다.</li>
<li>보간 탐색(interpolation search) 탐색키가 존재 할 위치를 예측하여 탐색합니다 (예를 들어 사전의 경우 'ㄱ'으로 시작하는 단어는 앞부분에서 찾음)</li>
</ul>
<h1 id="그래프">그래프</h1>
<ul>
<li>그래프는 광범위한 분야에서 활용되는 자료구조입니다.</li>
<li>그래프는 정점(Vertex)과 간선(Edge)의 집합으로 하나의 간선(a와 b를 연결하는 간선은 (a,b), 정점 a에서 b로 간선의 방향이 있는 경우 &lt;a.b&gt; 로 표시합니다)은 두개의 정점을 연결하며 그래프는 G=(V,E)로 표현됩니다(V는 정점의 집합, E는 간선의 집합). 이 때 방향 그래프는 간선에 방향이 있는 그래프를 뜻하며 무방향 그래프는 간선에 방향이 없는 그래프를 의미합니다. 차수(Degree)는 정점에 인접한 정점의 수를 의미하고 방향그래프에서는 차수를 진입차수(In-degree)와 진출 차수(Out-degree)로 구분합니다. 한편 경로는 시작 정점부터 도착점까지의 정점들을 나열하여 표현하며 a-&gt;d [a,b,c,d] 단순 경로(Simple Path)는 경로 상의 정점들이 모두 다른 경로를 의미합니다. 싸이클(Cycle)은 시작 정점과 도착점이 동일한 단순 경로 입니다.</li>
<li>연결성분(Connected)은 그래프에서 정점들이 서로 연결되어 있는 부분을 뜻합니다. 이중 연결성분(Biconnected Component)은 무방향 그래프의 연결성분에서 임의의 두 정점들 사이에 적어도 두 개의 단순 경로가 존재하는 연결성분으로 하나의 단순 경로 상의 어느 정점 하나가 삭제되더라도 연결성분내에서 정점들 사이의 연결이 유지됩니다. 연결성분의 정점들 중 하나의 정점을 삭제했을 때, 두 개 이상의 연결성분들로 분리될 경우 삭제된 정점은 단일 정점(Cut Point)으로 불리며 간선 제거로 인해 연결성분이 두 개 이상의 연결성분들로 분리될시 삭제된 간선은 다리 간선(Bridge)이라고 합니다. 강연결성분(Strongly Connected Component)는 방향그래프에서 연결성분 내의 임의의 두 정점 u와 v에 대해 양방향으로 오가는 경로가 존재하는 연결성분을의미하며 단절정점이나 다리 간선을 포함하지 않습니다.</li>
</ul>
<h2 id="그래프-종류">그래프 종류</h2>
<ul>
<li>가중치(weighted) 그래프: 간선에 가중치가 부여된 그래프</li>
<li>부분그래프(Subgraph): 주어진 그래프의 정점과 간선의 일부분(집합)으로 이루어진 그래프</li>
<li>트리(Tree): 싸이클이 없는 그래프</li>
<li>신장트리(Spanning Tree): 주어진 그래프가 하나의 연결성분으로 구성되어 있을 때, 그래프의 모든 정점들을 싸이클 없이 연결하는 부분그래프</li>
</ul>
<h2 id="그래프-자료구조">그래프 자료구조</h2>
<ul>
<li>그래프는 인접행렬(Adja cency Matrix) 또는 인접리스트(Adjacency List) 방법으로 저장할 수 있습니다.</li>
<li>정점의 평균 차수가 작은 희소 그래프(Sparse Graph)는 간선수가 최대간선수 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.938ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5276.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(888,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1277,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(2387.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3387.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(3887.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4276.4,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(4776.4,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></span>보다 훨씬 작으므로 인접리스트에 저장하는 것이 적절합니다. 간선의 수가 최대 간선 수에 근접한 그래프는 조밀 그래프(Dense Graph)라고 합니다.</li>
</ul>
<h2 id="그래프-탐색-방법">그래프 탐색 방법</h2>
<h3 id="깊이우선탐색dfs">깊이우선탐색(DFS)</h3>
<ul>
<li>그래프에서의 DFS는 임의의 정점에서 시작하여 이웃하는 하나의 정점을 방문하고, 방금 방문한 정점의 이웃 정점을 방문하며, 이웃하는 정점들을 모두 방문한 경우에는 이전 정점으로 되돌아 가서 탐색을 수행하는 방식으로 진행합니다.</li>
</ul>
<h3 id="너비우선탐색bfs">너비우선탐색(BFS)</h3>
<ul>
<li>BFS는 임의의 정점에서 시작하여 모든 이웃하는 정점들을 방문하고, 방문한 정점들의 이웃하는 정점들을 모두 방문하는 방식으로 그래프의 모든 정점을 방문합니다.</li>
</ul>
<h3 id="예시">예시</h3>
<p><img src="https://user-images.githubusercontent.com/84167756/151490808-0fde973e-713d-4dfa-8a86-c4b6f7239c13.png"></p>
<p>정점 3에서 출발</p>
<ul>
<li>DFS: 3-1-0-2-4-5-6-7-8-9</li>
<li>BFS: 3-1-4-5-0-2-6-7-8-9</li>
</ul>
<h2 id="기본적인-그래프-알고리즘">기본적인 그래프 알고리즘</h2>
<h3 id="연결성분-찾기">연결성분 찾기</h3>
<ul>
<li>주어진 정점으로부터 DFS를 수행하여 방문되는 정점들을 리스트로 모아서 1개의 연결성분을 만들고 방문 안된 정점으로부터 같은 과정을 반복하여 다른 연결성분들을 추출</li>
</ul>
<h3 id="위상정렬">위상정렬</h3>
<ul>
<li>위상 정렬(Topological Sort)이란 싸이클이 없는 방향그래프(Directed AcyclicGraph, DAG)에서 정점을 선형순서로 나열하는 것을 의미하며 그 결과 그래프의 각 간선 &lt;a,b&gt;에 대해 a가 반드시 b보다 앞서 나열되어야 합니다.</li>
<li>주어진 그래프에 따라 여러 개의 위상 정렬이 존재할 수 있으며 일반적으로 작업(Task)들 사이에 의존관계가 존재할 때 수행 가능한 작업 순서를 도식화 하는 데에 위상 정렬이 사용됩니다.</li>
</ul>
<h2 id="최소신장트리minimum-spanning-tree-mst">최소신장트리(Minimum Spanning Tree, MST)</h2>
<ul>
<li>최소신장트리는 하나의 연결성분으로 이루어진 무방향 가중치 그래프에서 간선의 가중치의 합이 최소인 신장트리를 의미하며 이를 찾는 대표적인 알고리즘 모두 그리디(Greedy) 알고리즘입니다.</li>
</ul>
<h3 id="kruskal-알고리즘">Kruskal 알고리즘</h3>
<ul>
<li>크루스칼(Kruskal)알고리즘은 간선들을 가중치가 감소하지 않는 순서(오름차순)로 정렬한 후 가장 가중치가 작은 간선을 트리에 추가하여 싸이클을 만들지 않으면 트리 간선으로 선택하고, 싸이클을 만들면 버리는 일을 반복하여 N-1개(N은 그래프 정점의 수)의 간선이 선택되었을 때 알고리즘을 종료합니다. 크루스칼 알고리즘이 그리디 알고리즘인 이유는 남아있는 (정렬된)간선들 중에서 항상 ‘욕심 내어’ 가중치가 가장 작은 간선을 가져오기 때문입니다.</li>
</ul>
<p>예시</p>
<p><img src="https://user-images.githubusercontent.com/84167756/151495585-c76367ba-074b-4faf-8f5f-db4376516089.png"> 의 경우</p>
<p><img src="https://user-images.githubusercontent.com/84167756/151495497-8f55d8ee-1cf9-435b-a51c-e730ee904228.png"></p>
<ul>
<li>위 정렬된 순서대로(위에서 아래로) 가장 가중치가 작은 간선을 트리에 추가하여 싸이클을 만들지 아니하면 트리 간선으로 선택하여 그 결과 (A, E), (C, I), (A, H), (B. D), (D, F), (E, G), (A, B), (G, I) 순서대로 총 8개(=9-1)의 간선을 추가하였습니다.</li>
<li>이 사건 N-1의 간선 숫자는 8개(N은 9)이며, 이후 간선들은 모두 싸이클을 만드는 경우에 해당하기에 삭제하였습니다(위 표에 푸른 칠을 하였습니다).</li>
<li>이와 같은 방법으로 구성한 그래프 2의 최소 신장 트리는 아래와 같습니다(붉은색 선이 선택된 간선).</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151495775-bd1f5792-c3b9-4247-a3f2-7b0d27a55830.png"></p>
<p>위 최소 신장 트리의 간선의 가중치의 합은 5+5+10+10+15+15+20+20=100 입니다.</p>
<h3 id="프림prim-알고리즘">프림(Prim) 알고리즘</h3>
<ul>
<li>프림(Prim) 알고리즘은 임의의 시작 정점에서 인접한 정점들 중 가중치가 가장 낮은 정점을 추가하여 간선이 하나인 트리를 만들고, 만들어진 트리에 인접한 가장 가까운 정점들 중 가중치가 제일 낮은 것을 하나씩 추가하여 최소신장트리를 만듭니다.</li>
</ul>
<p>예시</p>
<p><img src="https://user-images.githubusercontent.com/84167756/151498452-41756d39-560f-4c9f-b0f7-8e31013a726c.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151498391-ddc6fdcf-7768-47b1-b1b4-e35e4bd92917.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151498656-5ada37b5-fa27-4244-8fd8-90b6c1102a56.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">위 예시를 코드로 풀기</span><br><span class="line"><span class="keyword">import</span> sys <span class="comment"># sys.maxsize 사용 위해</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 노드 A는 0, B는 1, C는 2, D는 3, E는 4, F는 5, G는 6</span></span><br><span class="line">N=<span class="number">7</span> <span class="comment"># 노드 수</span></span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="comment">#정점</span></span><br><span class="line">g=[<span class="literal">None</span>]*N</span><br><span class="line"><span class="comment"># 입력 그래프의 인접 리스트</span></span><br><span class="line">g[<span class="number">0</span>]=[(<span class="number">1</span>,<span class="number">7</span>), (<span class="number">2</span>,<span class="number">15</span>), (<span class="number">4</span>,<span class="number">19</span>), (<span class="number">6</span>,<span class="number">10</span>)]</span><br><span class="line">g[<span class="number">1</span>]=[(<span class="number">0</span>,<span class="number">7</span>), (<span class="number">3</span>,<span class="number">12</span>), (<span class="number">4</span>,<span class="number">3</span>)]</span><br><span class="line">g[<span class="number">2</span>]=[(<span class="number">0</span>,<span class="number">15</span>), (<span class="number">5</span>,<span class="number">11</span>), (<span class="number">6</span>,<span class="number">6</span>)]</span><br><span class="line">g[<span class="number">3</span>]=[(<span class="number">1</span>,<span class="number">12</span>), (<span class="number">4</span>,<span class="number">18</span>), (<span class="number">5</span>,<span class="number">9</span>)]</span><br><span class="line">g[<span class="number">4</span>]=[(<span class="number">0</span>,<span class="number">19</span>), (<span class="number">1</span>,<span class="number">3</span>), (<span class="number">3</span>,<span class="number">18</span>), (<span class="number">5</span>,<span class="number">4</span>), (<span class="number">6</span>,<span class="number">9</span>)]</span><br><span class="line">g[<span class="number">5</span>]=[(<span class="number">2</span>,<span class="number">11</span>), (<span class="number">3</span>,<span class="number">9</span>), (<span class="number">4</span>,<span class="number">4</span>), (<span class="number">6</span>,<span class="number">16</span>)]</span><br><span class="line">g[<span class="number">6</span>]=[(<span class="number">0</span>,<span class="number">10</span>), (<span class="number">2</span>,<span class="number">6</span>), (<span class="number">4</span>,<span class="number">9</span>), (<span class="number">5</span>,<span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 초기화</span></span><br><span class="line">visited = [<span class="literal">False</span>]*N</span><br><span class="line">D=[sys.maxsize]*N <span class="comment"># 각 원소를 최대값으로</span></span><br><span class="line">D[s]=<span class="number">0</span>         <span class="comment"># 시작점</span></span><br><span class="line">previous=[<span class="literal">None</span>]*N <span class="comment"># 트리 간선 추출을 위해</span></span><br><span class="line">previous[s]=s <span class="comment"># 둘 사이 간선 존재</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(N): <span class="comment"># N개의 정점을 트리에 추가한 뒤 종료</span></span><br><span class="line">    <span class="comment"># 트리에서 가장 가까운 정점 m 찾기</span></span><br><span class="line">    m=-<span class="number">1</span> <span class="comment"># m은 최소 정점</span></span><br><span class="line">    min_value = sys.maxsize <span class="comment"># 파이썬에서 최대 정수 값을 리턴</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[j] <span class="keyword">and</span> D[j] &lt; min_value:</span><br><span class="line">            min_value=D[j]</span><br><span class="line">            m=j <span class="comment"># 방문 안된 정점들의 D 원소들 중에서 최솟값을 가진 정점 m 찾기</span></span><br><span class="line">    visited[m ]=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#최소 정점에 인접하면서 트리에 속하지 않는 정점의 D원소를 갱신</span></span><br><span class="line">    <span class="keyword">for</span> w, wt <span class="keyword">in</span> <span class="built_in">list</span>(g[m]): <span class="comment">#정점 m에 인접한 정점 m과 간선(m,w)의 가중치 wt에 대해</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[w]:</span><br><span class="line">            <span class="keyword">if</span> wt &lt; D[w]:</span><br><span class="line">                D[w]=wt <span class="comment"># D[w] 갱신</span></span><br><span class="line">                previous[w]=m <span class="comment"># D[w]가 정점 m 때문에 갱신되었음을 기록</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'추가된 정점:'</span>, m, <span class="string">'      '</span>, <span class="string">'갱신된리스트 D:'</span>, D)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'최대신장트리:'</span>, end=<span class="string">''</span>)</span><br><span class="line">cost=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'(%d, %d)'</span>% (i, previous[i]), end=<span class="string">''</span>)</span><br><span class="line">    cost+=D[i]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n최대신장트리 가중치:'</span>, cost)</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/84167756/151505225-5143e227-fc09-4a15-b15a-25462e05e092.png"></p>
<h3 id="djkstra-알고리즘">Djkstra 알고리즘</h3>
<ul>
<li>Djkstra 알고리즘의 핵심 아이디어는 그리디하게 정점을 선택하여 방문하고, 선택한 정점의 방문 안 된 인접한 정점들에 대한 간선 완화를 수행하며 한번 방문 된 정점의 D원소 값은 변하지 않는 것입니다.</li>
<li>아래 예시의 경우 정점 S에서 출발하며 파란색 숫자는 최단 경로 값, 빨간색 글자는 경유 노드입니다.</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/84167756/151506139-2e84c84c-1fb7-43f9-af3d-0781b078f11e.png"></p>
<p><img src="https://user-images.githubusercontent.com/84167756/151506174-ce6b4101-b8f1-4247-8f57-3eba03bcb428.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/01/24/3-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/" data-id="ckzw8zu6w0000z0viglhybw3l" data-title="3. 자료구조알고리즘" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/02/03/4-%EA%B8%B0%EA%B3%84%ED%95%99%EC%8A%B5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          4. 기계학습
        
      </div>
    </a>
  
  
    <a href="/2022/01/18/title/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2. 통계</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/02/15/%ED%8C%8C%EC%9D%B4%ED%86%A0%EC%B9%98-Pytorch/">6. 파이토치(Pytorch)</a>
          </li>
        
          <li>
            <a href="/2022/02/07/%EC%9E%90%EC%97%B0%EC%96%B4%EC%B2%98%EB%A6%AC/">5. 자연어처리</a>
          </li>
        
          <li>
            <a href="/2022/02/04/%EC%98%A4%EC%B0%A8%EC%97%AD%EC%A0%84%ED%8C%8C-%EB%8D%A7%EC%85%88-%EB%85%B8%EB%93%9C-%EA%B3%B1%EC%85%88-%EB%85%B8%EB%93%9C/">계산 그래프로 이해한 오차역전파(덧셈 노드, 곱셈 노드)</a>
          </li>
        
          <li>
            <a href="/2022/02/03/4-%EA%B8%B0%EA%B3%84%ED%95%99%EC%8A%B5/">4. 기계학습</a>
          </li>
        
          <li>
            <a href="/2022/01/24/3-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">3. 자료구조알고리즘</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 Sebastian (Il-Hyun) Noh<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>